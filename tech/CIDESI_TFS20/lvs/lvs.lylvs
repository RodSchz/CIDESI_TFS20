<?xml version="1.0" encoding="utf-8"?>
<klayout-macro>
 <description>LVS para CIDESI_TFS20</description>
 <version>0.1</version>
 <category>lvs</category>
 <prolog/>
 <epilog/>
 <doc/>
 <autorun>false</autorun>
 <autorun-early>false</autorun-early>
 <priority>0</priority>
 <shortcut/>
 <show-in-menu>true</show-in-menu>
 <group-name>lvs_scripts</group-name>
 <menu-path>tools_menu.lvs.end</menu-path>
 <interpreter>dsl</interpreter>
 <dsl-interpreter-name>lvs-dsl-xml</dsl-interpreter-name>
 <text># DRC para proceso "CIDESI_TFS10"
# Autor: Rodolfo Sanchez Fraga
# Fecha: Abril-2025
# Centro de Ingeniería y Desarrollo Industrial
  
  deep
  report_lvs
    
  # Definición de capas
  substrate = input(1,1)
  oxide_cut = input(1,0)
  oxide = substrate-oxide_cut
  metal = input(2,0)
  nitride_cut = input(3,0)
  nitride = substrate-nitride_cut
  pin = input(4,0)
  cap_sel = input(5,0)
  cap_pin1 = input(5,1)
  cap_pin2 = input(5,2)
  metal_labels = labels(6, 0)
  cap_labels = labels(5,3)
  
  idm1 = cap_sel-metal
  idm2 = cap_sel-metal
   
  # Extraccion de resistores
  sheet_rho = 1.8719
  extract_devices(resistor("RTFS20", sheet_rho),{ "R" =&gt; metal, "C" =&gt; pin })
  
  # Extracción de capacitores laterales
  lateral_cap = 2.6646e-19
  extract_devices(capacitor(" ",lateral_cap),{ "P1" =&gt; idm1, "P2" =&gt; idm2, "tA" =&gt;cap_pin1, "tB" =&gt; cap_pin2})
  
  #connect(metal,pin)
  connect(pin,metal_labels)
  connect(cap_pin1,cap_labels)
  connect(cap_pin2,cap_labels)
  connect(cap_pin1,pin)
  connect(cap_pin2,pin)
  #connect(metal,metal_labels)
  
  netlist.make_top_level_pins
  #netlist.flatten_circuit("*")
  netlist.purge
  netlist.purge_nets
  
  puts "Elementos extraidos"
  puts netlist.to_s
  
  puts "Generando archivos"
  
  # Obtener ruta del layout
  view = RBA::Application.instance.main_window.current_view
  if view &amp;&amp; view.active_cellview
    layout_path = view.active_cellview.filename
    output_dir = File.dirname(layout_path)
  else
    output_dir = Dir.pwd
  end
    
  use_net_names = true
  with_comments = false
  target_netlist("netlist.cir", write_spice(use_net_names,with_comments), "Netlist generado, proceso CIDESI_TFS20")
 
  # Generar archivo .lib con modelos
  lib_path = GenerateModels.create_rtd_lib(0.64, output_dir)  # 0.64 es sheet_rho

  require 'digest'

  netlist_orig = File.join(output_dir, "netlist.cir")
  netlist_lts  = File.join(output_dir, "netlist_ltspice.cir")

  puts "[DBG] orig path: #{netlist_orig}"
  puts "[DBG] lts  path: #{netlist_lts}"
  
  raise "[ERR] No existe #{netlist_orig}" unless File.exist?(netlist_orig)
  
  orig_text = File.read(netlist_orig)
  orig_md5  = Digest::MD5.hexdigest(orig_text)
  puts "[DBG] orig md5: #{orig_md5}"
  puts "[DBG] orig mtime: #{File.mtime(netlist_orig)}"
  
  rx = /^(\s*R\S+\s+\S+\s+\S+)\s+([+-]?\d*\.?\d+(?:[eE][+-]?\d+)?(?:[a-zA-Z]+)?)\s+(RTFS20)\b/
  count = 0
  new_text = orig_text.gsub(rx) do
    count += 1
    "#{$1} #{$3} #{$2}"
  end
  
  puts "[DBG] reemplazos: #{count}"
  
  File.write(netlist_lts, new_text)
  
  lts_text = File.read(netlist_lts)
  lts_md5  = Digest::MD5.hexdigest(lts_text)
  puts "[DBG] lts md5:  #{lts_md5}"
  puts "[DBG] lts mtime: #{File.mtime(netlist_lts)}"
  
  puts "[DBG] preview lts:"
  lts_text.lines.first(10).each_with_index { |ln, i| puts "[DBG] #{i+1}: #{ln.chomp}" }
  
  if orig_md5 == lts_md5
    puts "[WARN] netlist_ltspice.cir quedó idéntico al original"
  else
    puts "[OK] netlist_ltspice.cir generado con cambios"
  end

  
  puts "Proceso completado."</text>
</klayout-macro>

